//#include "stdafx.h"
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <omp.h>
#include "allocate.h"
#include <iostream>
#include <fstream>
#include <ctime>
#include <fstream>

// OPENCV_3.1 Includes
#include <opencv2/core/core.hpp>           
#include <opencv2/highgui/highgui.hpp>     
#include <opencv2/imgproc/imgproc.hpp>  

using namespace std;
using namespace cv;


#define MAX_CLASSES	256
#define MAXPRIME	2147483647       /*  MAXPRIME = (2^31)-1     */
#define PI			3.14159265358979323846

//unsigned char	**get_img(int,int,unsigned char);
unsigned char	**gamma[1000], **atlas[1000];
int	i, j, l, k, c, r, edgevalue, texturevalue, texturevalueCr, texturevalueCb, tempmin, counter = 0;
double mm, AveCost, diff[MAX_CLASSES+1], prior[MAX_CLASSES+1], DiSum, PiSum, assist;
double **xrv, x, flag, ratio,current, invannealtemp;
double sum = 0.0;
ofstream outfile("logpost.txt",ios::out);

double random2();
unsigned long srandom2(unsigned long num);
void readseed(void);
void writeseed(unsigned long seed);
double callogpost(double **diff_sq[], double **atlas[], unsigned char **xttemp[], int cols, int rows, int ATLAS, double gama, int classes, double beta, double *d, double *con, double *logpost, int edgevalue, int texturevalue, IplImage *highpass, IplImage* texture);


///////////////////////////////////////////////////////////////////////////////////
//																				 //
//    Part 1:																	 //
//			Generate Random numbers                                              //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////


/* PORTABILITY 1:  The functions in this file assume that a long is 32 bits
      and a short is 16 bits.  These conventions are machine dependent and
      must therefore be verified before using.                     */

static unsigned long   sd[2],tmp;   /*  tmp: 31 bit seed in GF( (2^31)-1 )   */
                                    /*  sd[0]: high order 15 bits of tmp     */
                                    /*  sd[1]: low order 16 bits of tmp      */
                 /* NOTE: high order 16 bits of sd[0] and sd[1] are 0        */

//Set a new seed for random # generator 
unsigned long srandom2(unsigned long num)
{
	tmp=num;
	*sd=tmp>>16;
	*(sd+1)=tmp & 0xffff;

	return *sd;
}	// end of srandom2

/*  Reads random # generator seed from file: /tmp/randomseedmlc */
void readseed(void)
{
	ifstream randFile("randomseedmlc.txt", ios::in);
	unsigned long seed;

	if (randFile.is_open())
	{
		randFile >> seed;
		tmp = srandom2(seed);
		randFile.close();
	}
	else
	{
		cout << stderr << "readseed: reading file randomseedmlc" << endl;
		seed=143542612;
		writeseed(seed);
		tmp = srandom2(seed);
	}


}	// end of readseed


/*  Writes random # generator seed from file: /tmp/randomseedmlc */
void writeseed(unsigned long seed)
{
	//FILE  *fp1;
	//char	*calloc();
	ofstream randFile("randomseedmlc.txt", ios::out);


	if (randFile.is_open())
	{
		randFile << seed;
		randFile.close();
	}
	else
	{
		fprintf(stderr,"writeseed: can't open file /tmp/randomseedmlc\n");
		exit(1);
	} 

}	// end of writeseed

//Uniform random number generator on (0,1]
//Algorithm:  newseed = (16807 * oldseed) MOD [(2^31) - 1]  ;
//            returned value = newseed / ( (2^31)-1 )  ;
//    newseed is stored in tmp and sd[0] and sd[1] are updated;
//    Since 16807 is a primitive element of GF[(2^31)-1], repeated calls
//    to random2() should generate all positive integers <= MAXPRIME
//    before repeating any one value.
//	Tested: Feb. 16, 1988;  verified the length of cycle of integers 
//                             generated by repeated calls to random2()
double random2()
{
	*(sd+1) *= 16807;
	*sd *= 16807;

	tmp=((*sd)>>15)+(((*sd)&0x7fff)<<16);
	tmp += (*(sd+1));

	if ( tmp & 0x80000000 ) 
	{
		tmp++;
		tmp &= 0x7fffffff;
	}

	*sd=tmp>>16;
	*(sd+1)=tmp & 0xffff;

	return(((double)tmp)/MAXPRIME);   
}	// end of random2

//////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
//																				 //
//    Part 2:																	 //
//			Subfunction of calculating logpost                                   //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////


double callogpost(double **diff_sq[], double **atlas[],unsigned char **xttemp[],int cols, int rows, int ATLAS, double gama, int classes, double beta, double *d, double *con, double *logpost, int edgevalue, int texturevalue, IplImage *highpass, IplImage* texture)
{		
	int edgevalue1,texture1;
	double weight;
	double alpha = 1.0;
	double tempsq;
//////////// More Texture region //////////////////////////////////////////////////////////////////////////////////////

	if (texturevalue == 0 ) // more texture region
		{					
			for (k=1; k<=MAX_CLASSES; k++)
				{
					prior[k] = 0;
					diff[k] = 0;
					diff[k]+=diff_sq[k][i][j];

					//**************************************************************************//
					if (i-1 >= 0) 
						{                       							
						  prior[k]+=(double)abs(xttemp[0][i-1][j]-k); 
						  diff[k]+=diff_sq[k][i-1][j]; //neighbors difference       left	
									
						  if (j-1 >=0) {
										diff[k]+=diff_sq[k][i-1][j-1]; //neighbors difference    left top  
										prior[k]+=(double)abs(xttemp[0][i-1][j-1]-k); 
									   }                           
						  if (j+1 <= cols-1) 
									   {
										diff[k]+=diff_sq[k][i-1][j+1]; //neighbors difference   left bottom
										prior[k]+=(double)abs(xttemp[0][i-1][j+1]-k); 
									   } 
						}

					//**************************************************************************//
					if (i+1 <= rows-1) 
						{						
						  prior[k]+=(double)abs(xttemp[0][i+1][j]-k);
						  diff[k]+=diff_sq[k][i+1][j]; //neighbors difference

						  if (j-1 >=0) {
										diff[k]+=diff_sq[k][i+1][j-1];
										prior[k]+=(double)abs(xttemp[0][i+1][j-1]-k); 
									   } 									
						  if (j+1 <= cols-1) 
									   {      
										diff[k]+=diff_sq[k][i+1][j+1];
										prior[k]+=(double)abs(xttemp[0][i+1][j+1]-k); 
									   }
						}

					//**************************************************************************//
					if (j-1 >=0) 
					    {									
						  prior[k]+=(double)abs(xttemp[0][i][j-1]-k);									
						  diff[k]+=diff_sq[k][i][j-1]; //neighbors difference
						}

					//**************************************************************************//
					if (j+1 <= cols-1) 
					    {									
						  prior[k]+=(double)abs(xttemp[0][i][j+1]-k);
						  diff[k]+=diff_sq[k][i][j+1]; //neighbors difference
						}
				}
		}

//////////// Less Texture region //////////////////////////////////////////////////////////////////////////////

		if (texturevalue == 255  ) // less texture 
			{	
			    for (k=1; k<=MAX_CLASSES; k++)
				{
				  prior[k] = 0;
				  diff[k] = 0;
				  diff[k]+=diff_sq[k][i][j];

				  //**************************************************************************//
				  if (i-1 >= 0) 
				     {                       
						if (xttemp[0][i-1][j] != k) 
							{	
								texture1=cvGetReal2D(texture, i-1, j);	
								if (texture1==0 ) 
									{
									  alpha=0;
									  weight=10;
									  if ( abs(xttemp[0][i-1][j]-xttemp[0][i][j])<1 ) cvSetReal2D(texture, i, j,0);
									}
								else 
									{
									  edgevalue1=cvGetReal2D(highpass, i-1, j); 
									  if (edgevalue1 == 0) weight = 0.08;
									  if (edgevalue1 != 0) weight = 1.0;
									}										
								prior[k]+=weight*(double)abs(xttemp[0][i-1][j]-k); 
							}

						 diff[k]+=diff_sq[k][i][j]; //neighbors difference       left	

						 if (j-1 >=0) (diff[k]+=diff_sq[k][i-1][j-1]); //neighbors difference    left top     

						 if (j+1 <= cols-1) (diff[k]+=diff_sq[k][i-1][j+1]); //neighbors difference   left bottom
						}

				    //**************************************************************************//
					if (i+1 <= rows-1) 
					    {					
						  if (xttemp[0][i+1][j] != k) 
							{
								texture1=cvGetReal2D(texture, i+1, j);	
								if (texture1==0 )
									{
									  alpha=0;
									  weight=10;
									  if (abs(xttemp[0][i+1][j]-xttemp[0][i][j])<1) cvSetReal2D(texture, i, j,0);
									}
								else 
									{
									  edgevalue1=cvGetReal2D(highpass, i+1, j); 
									  if (edgevalue1 == 0) weight = 0.08;
									  if (edgevalue1 != 0) weight = 1.0;
									}
								prior[k]+=weight*(double)abs(xttemp[0][i+1][j]-k);
							}
									
						  if (j-1 >=0) (diff[k]+=diff_sq[k][i+1][j-1]); //neighbors difference

						  diff[k]+=diff_sq[k][i+1][j]; //neighbors difference
						  if (j+1 <= cols-1) (diff[k]+=diff_sq[k][i+1][j+1]); //neighbors difference//////////////////////////////////////error
						}

					//**************************************************************************//
					if (j-1 >=0) 
					  {
						if (xttemp[0][i][j-1] != k) 
						 {
							texture1=cvGetReal2D(texture, i, j-1);	
							if (texture1==0 ) 
							  {
								alpha=0;
								weight=10;
								if (abs(xttemp[0][i][j-1]-xttemp[0][i][j])<1) cvSetReal2D(texture, i, j,0);
							  }
							else 
							  {
								edgevalue1=cvGetReal2D(highpass, i, j-1); 
								if (edgevalue1 == 0) weight = 0.08;
								if (edgevalue1 != 0) weight = 1.0;
							  }
								prior[k]+=weight*(double)abs(xttemp[0][i][j-1]-k);
						  }
									
						diff[k]+=diff_sq[k][i][j-1]; //neighbors difference
					  }

					//**************************************************************************//
					if (j+1 <= cols-1) 
					  {
						if (xttemp[0][i][j+1] != k) 
						 {
							texture1=cvGetReal2D(texture, i, j+1);	
							if (texture1==0 ) 
							  {
								alpha=0;
								weight=10;
								if( abs(xttemp[0][i][j+1]-xttemp[0][i][j])<1) cvSetReal2D(texture, i, j,0);
							  }
							else 
							  {
								edgevalue1=cvGetReal2D(highpass, i, j+1); 
								if (edgevalue1 == 0) weight = 0.08;
								if (edgevalue1 != 0) weight = 1.0;
							  }
							prior[k]+=weight*(double)abs(xttemp[0][i][j+1]-k);
						 }
									
						 diff[k]+=diff_sq[k][i][j+1]; //neighbors difference
					   }		
				 }
			}


//////////// combine by Bayes rule log p(X|Y) = log(p(Y|X)  + p(X)  + Gamma , using attenuation Function call //////////////////////////////////////////////////////////////////////////////
      for (k=1; k<=classes; k++)
          {
			if (texturevalue == 0 & edgevalue == 0 ) beta = 0.1;   // more texture region and pixel not on edge
			if (texturevalue == 0 & edgevalue != 0 ) beta = 0.01;	// more texture region and pixel  on edge
			if (texturevalue == 255 & edgevalue == 0 ) beta = 1.5; // less texture region and pixel not on edge
			if (texturevalue == 255 & edgevalue != 0 ) beta = 0.01; // less texture region and pixel  on edge

            /* calculating gamma term */
		    if (atlas[0][i][j] == k)   gamma[0][i][j] = 0;
            if (atlas[0][i][j] != k)   gamma[0][i][j] = 1;

			if (prior[k] < 0) (prior[k]=0); assist =  gama * gamma[0][i][j];
			/* Switch for atlas method */
			if (ATLAS==1)
                 logpost[k] = diff[k] + beta*(double)(prior[k]) + assist;
            if (ATLAS==0)
				logpost[k] = con[k] + alpha*(diff[k]/d[k]) + beta*(double)(prior[k]);
	      }

 return *logpost;
}


///////////////////////////////////////////////////////////////////////////////////
//																				 //
//    Part 3:																	 //
//			Revised MAP Estimation Function                                      //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////



void map3(double **y[], double **xt[], double **diff_y[], double **diff_Cr[], double **diff_Cb[], double **atlas[], double beta,double gama, int ATLAS, int ICM, int cols, int rows, int classes, int map_iter, double *v, double yaccum[], double ysquaredaccum[], double Num[], unsigned char **xttemp[],unsigned char **xttempCr[],unsigned char **xttempCb[], Mat texture, Mat textureCb, Mat textureCr, Mat highpass, Mat highpassCr, Mat highpassCb)
{
	gamma[0] = (unsigned char **)get_img(cols,rows,sizeof(unsigned char));
	double logpost[MAX_CLASSES+1], logpostCr[MAX_CLASSES+1], logpostCb[MAX_CLASSES+1], logposty[MAX_CLASSES+1];
	xrv= (double **)get_img(cols,rows,sizeof(double));
	diff[0]=0;
	logpost[0]=0;
	prior[0]=0;
	double compare[MAX_CLASSES+1];

	readseed();

////////////////////////////////////////////////////////////////////////////////

	double sqrt2pi;
	double con[MAX_CLASSES + 1] = { 0 };	// not originally filled with 0's
	double d[MAX_CLASSES + 1] = { 0 };	// not originally filled with 0's
	double mean[MAX_CLASSES + 1];
	double var[MAX_CLASSES + 1];

	/*  constant  */
	sqrt2pi = sqrt(2.0*PI);

	/*  constants for each class due to variance  */
	for (k = 1; k <= classes; k++)
	{
		if (v[k] < 0.025)
		{
			v[k] = 0.025;
		}
		else
		{
			con[k] = log(sqrt2pi*sqrt(v[k]));
		}

		if (con[k] < 0)
		{
			con[k] = 0;
		}
		else
		{
			d[k] = 2.0*v[k];
		}

		for (i=0; i<rows; i++)
			for (j=0; j<cols; j++)
				{	
					diff_y[k][i][j] = diff_y[k][i][j]/d[k];
					diff_Cr[k][i][j] = diff_Cr[k][i][j]/d[k];
					diff_Cb[k][i][j] = diff_Cb[k][i][j]/d[k];
					}

	}	// end of for k loop

	// initialize accumulation registers
	//for (k=1; k<=classes; k++) 
	//{
	//	mean[k]=0;
	//	var[k]=0;
	//	yaccum[k]=0;
	//	ysquaredaccum[k]=0;
	//	Num[k]=0;
	//}

	memset(mean, 0, classes);
	memset(var, 0, classes);
	memset(yaccum, 0, classes);
	memset(ysquaredaccum, 0, classes);
	memset(Num, 0, classes);

///////////////////////////////////////////////////////////////////////////////////////

	/* Map loop */
	for (l=0; l<map_iter; l++)
    {
		AveCost = 0; 

		/* Initialize random variable array */
		for (i = 0; i < rows; i++)
		{
			for (j = 0; j < cols; j++)
			{
				xrv[i][j] = random2();
			}
		}


		//**************************************************************************//
		// Begin calculation pixel by pixel
	    for (i=0; i<rows; i++)
           for (j=0; j<cols; j++)
            {

		//**************************************************************************//
		// Calculating diff temm 
			    mm=(double)y[0][i][j];
				//mm = (double)y[l][i][j];	// changed the first index from 1 to l <- doesn't work

/////////////////////////////////   read in texture and edge information for each pixel ////////////////////////////
				//texturevalue=cvGetReal2D(texture, i, j);
				//texturevalueCr=cvGetReal2D(textureCr, i, j);
				//texturevalueCb=cvGetReal2D(textureCb, i, j);

				//cout << "test" << endl;

				//texturevalue = texture.at<UINT8>(i, j);
				//texturevalueCr = textureCr.at<UINT8>(i, j);
				//texturevalueCb = textureCb.at<UINT8>(i, j);

				if (texturevalue == 255)
				{
					beta = 0.1; //    texture
				}
				if (texturevalue == 0)
				{
					beta = 0.01;
				}
/*
				//edgevalue=cvGetReal2D(highpass, i, j);
				edgevalue = highpass.at<UNIT8>(i, j);
				*logposty=callogpost(diff_y,atlas,xttemp,cols, rows,  ATLAS,  gama, classes,  beta,  d, con,logposty,edgevalue,texturevalue,highpass,texture);
				
				//edgevalue=cvGetReal2D(highpassCr, i, j);
				edgevalue = highpassCr.at<UNIT8>(i, j);
				*logpostCr=callogpost(diff_Cr,atlas,xttempCr,cols, rows,  ATLAS,  gama, classes,  beta,  d, con, logpostCr,edgevalue,texturevalueCr,highpassCr,textureCr);
							
				//edgevalue=cvGetReal2D(highpassCb, i, j);
				edgevalue = highpassCb.at<UNIT8>(i, j);
				*logpostCb=callogpost(diff_Cb,atlas,xttempCb,cols, rows,  ATLAS,  gama, classes,  beta,  d, con,logpostCb,edgevalue,texturevalueCb,highpassCb,textureCb);
*/
				for (k=1; k<=MAX_CLASSES; k++)
				{ 
					logpost[k]=(logposty[k]+logpostCr[k]+logpostCb[k]);	
				}
               
                /*  find min of logpost[k] */
                if (ICM == 1)
                {
                    tempmin = 1;
                    for (k=1; k<=classes; k++)
                    {
                        if ((logpost[tempmin])>(logpost[k])) tempmin=k;
                    }
                    xttemp[0][i][j]=tempmin;
					xttempCr[0][i][j]=tempmin;
					xttempCb[0][i][j]=tempmin;                  
                }
                else 
				{	
					if (ICM == 0) 
						invannealtemp = log((float)(l+2))/3.0;

					if (ICM == 2) 
						invannealtemp = 1.0;

					double sum = 0.0;

					for (k=1; k<=classes; k++) 
					{
						compare[k] = exp(-invannealtemp*logpost[k]*10);
						sum += compare[k];
					}

					while (sum==0)
					{
					  for (k=1; k<=classes; k++) 
						{	
						  compare[k] = exp(-invannealtemp*logpost[k]/100);
						  sum += compare[k];
						}		
					}

					current = 0;

					for (k=1; k<=classes; k++)
					{
						ratio=(compare[k])/sum;
					
						if (((xrv[i][j])>=current)&&((xrv[i][j])<=(current + ratio)))
						{
							xttemp[0][i][j] = k;
							xttempCr[0][i][j] = k;
							xttempCb[0][i][j] = k;
						}
			
                        current += ratio;
					}
				}

				# pragma omp critical 
				{
					yaccum[(xttemp[0][i][j])] += mm;					/* for mean EM calculation*/ 
					ysquaredaccum[(xttemp[0][i][j])] += (mm)*(mm);		/* for variance EM caculation */
					Num[(xttemp[0][i][j])] += 1;						/* for mean & variance EM calculation*/ 										
				}				

			AveCost += logpost[xttemp[0][i][j]];
		} 

	//**************************************************************************//
		std::cout<<"Total cost for iteration #"<<l<<" is : "<<AveCost<<"\n";
		
		for (i = 0; i < rows; i++)
		{
			for (j = 0; j < cols; j++)
			{
				xt[0][i][j] = unsigned(255.0 - ((256.0 / MAX_CLASSES)*(xttemp[0][i][j] - 1.0)));
			}
		}

    }

}	// end of map3



