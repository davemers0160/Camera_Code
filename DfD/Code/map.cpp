//#include "stdafx.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <omp.h>
#include "allocate.h"
#include <iostream>
#include <fstream>
#include <time.h>
#include <fstream>

// OPENCV_3.1 Includes
#include <opencv2/core/core.hpp>           
#include <opencv2/highgui/highgui.hpp>     
#include <opencv2/imgproc/imgproc.hpp>  

using namespace std;
using namespace cv;

#define PI  3.1415926535897932386
#define MAX_CLASSES 256
#define MAXPRIME  2147483647       /*  MAXPRIME = (2^31)-1     */
#define PI        3.14159265358979323846

//unsigned char	**get_img(int,int,unsigned char);
unsigned char	**gamma[1000], **atlas[1000];
int				i,j,l,k,c,r,edgevalue,texturevalue,texturevalueCr,texturevalueCb,tempmin,counter = 0;
double			random2(),mm,sum,AveCost,diff[MAX_CLASSES+1], prior[MAX_CLASSES+1],DiSum,PiSum, assist;
double			**xrv, x, flag, ratio,current,invannealtemp, compare[MAX_CLASSES];

ofstream outfile("logpost.txt",ios::out);

double callogpost(double **diff_sq[],double **atlas[],unsigned char **xttemp[],int cols, int rows, int ATLAS, double gama, int classes, double beta, double *d, double *con, double *logpost, int edgevalue, int texturevalue, IplImage *highpass, IplImage* texture);

///////////////////////////////////////////////////////////////////////////////////
//																				 //
//    Part 1:																	 //
//			Generate Random numbers                                              //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////


/* PORTABILITY 1:  The functions in this file assume that a long is 32 bits
      and a short is 16 bits.  These conventions are machine dependent and
      must therefore be verified before using.                     */

static unsigned long   sd[2],tmp;   /*  tmp: 31 bit seed in GF( (2^31)-1 )   */
                                    /*  sd[0]: high order 15 bits of tmp     */
                                    /*  sd[1]: low order 16 bits of tmp      */
                 /* NOTE: high order 16 bits of sd[0] and sd[1] are 0        */

unsigned long srandom2(unsigned long num)
/* Set a new seed for random # generator  */
{
 tmp=num;
 *sd=tmp>>16;
 *(sd+1)=tmp & 0xffff;
 return *sd;
}

void readseed()
/*  Reads random # generator seed from file: /tmp/randomseedmlc */
{
 FILE	*fp1;
 char	*calloc();
 void	writeseed();

   if((fp1 = fopen("randomseedmlc","r"))==NULL ) {
     fprintf(stderr,"readseed: creating file /tmp/randomseedmlc\n");
     tmp=143542612;
     writeseed();
     srandom2(tmp);
   } else {
     fscanf(fp1,"%d",&tmp);
     srandom2(tmp);
     fclose(fp1);
   }
}

void writeseed()
/*  Writes random # generator seed from file: /tmp/randomseedmlc */
{
 FILE  *fp1;
 char	*calloc();

   if((fp1 = fopen("randomseedmlc","w"))==NULL ) {
     fprintf(stderr,"writeseed: can't open file /tmp/randomseedmlc\n");
     exit(1);
   } else {
     fprintf(fp1,"%d",tmp);
     fclose(fp1);
   }
}


double random2()
/* Uniform random number generator on (0,1] */
/*  Algorithm:  newseed = (16807 * oldseed) MOD [(2^31) - 1]  ;
                returned value = newseed / ( (2^31)-1 )  ;
      newseed is stored in tmp and sd[0] and sd[1] are updated;
      Since 16807 is a primitive element of GF[(2^31)-1], repeated calls
      to random2() should generate all positive integers <= MAXPRIME
      before repeating any one value.
    Tested: Feb. 16, 1988;  verified the length of cycle of integers 
                             generated by repeated calls to random2()  */
{
 *(sd+1) *= 16807;
 *sd *= 16807;
 tmp=((*sd)>>15)+(((*sd)&0x7fff)<<16);
 tmp += (*(sd+1));
 if ( tmp & 0x80000000 ) {
   tmp++;
   tmp &= 0x7fffffff;
 }
 *sd=tmp>>16;
 *(sd+1)=tmp & 0xffff;
 return(((double)tmp)/MAXPRIME);   
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
//																				 //
//    Part 2:																	 //
//			Subfunction of calculating logpost                                   //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////


double callogpost(double **diff_sq[], double **atlas[],unsigned char **xttemp[],int cols, int rows, int ATLAS, double gama, int classes, double beta, double *d, double *con, double *logpost, int edgevalue, int texturevalue, IplImage *highpass, IplImage* texture)
{		
	int edgevalue1,texture1;
	double weight;
	double alpha = 1.0;
	double tempsq;
//////////// More Texture region //////////////////////////////////////////////////////////////////////////////////////

	if (texturevalue == 0 ) // more texture region
		{					
			for (k=1; k<=MAX_CLASSES; k++)
				{
					prior[k] = 0;
					diff[k] = 0;
					diff[k]+=diff_sq[k][i][j];

					//**************************************************************************//
					if (i-1 >= 0) 
						{                       							
						  prior[k]+=(double)abs(xttemp[0][i-1][j]-k); 
						  diff[k]+=diff_sq[k][i-1][j]; //neighbors difference       left	
									
						  if (j-1 >=0) {
										diff[k]+=diff_sq[k][i-1][j-1]; //neighbors difference    left top  
										prior[k]+=(double)abs(xttemp[0][i-1][j-1]-k); 
									   }                           
						  if (j+1 <= cols-1) 
									   {
										diff[k]+=diff_sq[k][i-1][j+1]; //neighbors difference   left bottom
										prior[k]+=(double)abs(xttemp[0][i-1][j+1]-k); 
									   } 
						}

					//**************************************************************************//
					if (i+1 <= rows-1) 
						{						
						  prior[k]+=(double)abs(xttemp[0][i+1][j]-k);
						  diff[k]+=diff_sq[k][i+1][j]; //neighbors difference

						  if (j-1 >=0) {
										diff[k]+=diff_sq[k][i+1][j-1];
										prior[k]+=(double)abs(xttemp[0][i+1][j-1]-k); 
									   } 									
						  if (j+1 <= cols-1) 
									   {      
										diff[k]+=diff_sq[k][i+1][j+1];
										prior[k]+=(double)abs(xttemp[0][i+1][j+1]-k); 
									   }
						}

					//**************************************************************************//
					if (j-1 >=0) 
					    {									
						  prior[k]+=(double)abs(xttemp[0][i][j-1]-k);									
						  diff[k]+=diff_sq[k][i][j-1]; //neighbors difference
						}

					//**************************************************************************//
					if (j+1 <= cols-1) 
					    {									
						  prior[k]+=(double)abs(xttemp[0][i][j+1]-k);
						  diff[k]+=diff_sq[k][i][j+1]; //neighbors difference
						}
				}
		}

//////////// Less Texture region //////////////////////////////////////////////////////////////////////////////

		if (texturevalue == 255  ) // less texture 
			{	
			    for (k=1; k<=MAX_CLASSES; k++)
				{
				  prior[k] = 0;
				  diff[k] = 0;
				  diff[k]+=diff_sq[k][i][j];

				  //**************************************************************************//
				  if (i-1 >= 0) 
				     {                       
						if (xttemp[0][i-1][j] != k) 
							{	
								texture1=cvGetReal2D(texture, i-1, j);	
								if (texture1==0 ) 
									{
									  alpha=0;
									  weight=10;
									  if ( abs(xttemp[0][i-1][j]-xttemp[0][i][j])<1 ) cvSetReal2D(texture, i, j,0);
									}
								else 
									{
									  edgevalue1=cvGetReal2D(highpass, i-1, j); 
									  if (edgevalue1 == 0) weight = 0.08;
									  if (edgevalue1 != 0) weight = 1.0;
									}										
								prior[k]+=weight*(double)abs(xttemp[0][i-1][j]-k); 
							}

						 diff[k]+=diff_sq[k][i][j]; //neighbors difference       left	

						 if (j-1 >=0) (diff[k]+=diff_sq[k][i-1][j-1]); //neighbors difference    left top     

						 if (j+1 <= cols-1) (diff[k]+=diff_sq[k][i-1][j+1]); //neighbors difference   left bottom
						}

				    //**************************************************************************//
					if (i+1 <= rows-1) 
					    {					
						  if (xttemp[0][i+1][j] != k) 
							{
								texture1=cvGetReal2D(texture, i+1, j);	
								if (texture1==0 )
									{
									  alpha=0;
									  weight=10;
									  if (abs(xttemp[0][i+1][j]-xttemp[0][i][j])<1) cvSetReal2D(texture, i, j,0);
									}
								else 
									{
									  edgevalue1=cvGetReal2D(highpass, i+1, j); 
									  if (edgevalue1 == 0) weight = 0.08;
									  if (edgevalue1 != 0) weight = 1.0;
									}
								prior[k]+=weight*(double)abs(xttemp[0][i+1][j]-k);
							}
									
						  if (j-1 >=0) (diff[k]+=diff_sq[k][i+1][j-1]); //neighbors difference

						  diff[k]+=diff_sq[k][i+1][j]; //neighbors difference
						  if (j+1 <= cols-1) (diff[k]+=diff_sq[k][i+1][j+1]); //neighbors difference//////////////////////////////////////error
						}

					//**************************************************************************//
					if (j-1 >=0) 
					  {
						if (xttemp[0][i][j-1] != k) 
						 {
							texture1=cvGetReal2D(texture, i, j-1);	
							if (texture1==0 ) 
							  {
								alpha=0;
								weight=10;
								if (abs(xttemp[0][i][j-1]-xttemp[0][i][j])<1) cvSetReal2D(texture, i, j,0);
							  }
							else 
							  {
								edgevalue1=cvGetReal2D(highpass, i, j-1); 
								if (edgevalue1 == 0) weight = 0.08;
								if (edgevalue1 != 0) weight = 1.0;
							  }
								prior[k]+=weight*(double)abs(xttemp[0][i][j-1]-k);
						  }
									
						diff[k]+=diff_sq[k][i][j-1]; //neighbors difference
					  }

					//**************************************************************************//
					if (j+1 <= cols-1) 
					  {
						if (xttemp[0][i][j+1] != k) 
						 {
							texture1=cvGetReal2D(texture, i, j+1);	
							if (texture1==0 ) 
							  {
								alpha=0;
								weight=10;
								if( abs(xttemp[0][i][j+1]-xttemp[0][i][j])<1) cvSetReal2D(texture, i, j,0);
							  }
							else 
							  {
								edgevalue1=cvGetReal2D(highpass, i, j+1); 
								if (edgevalue1 == 0) weight = 0.08;
								if (edgevalue1 != 0) weight = 1.0;
							  }
							prior[k]+=weight*(double)abs(xttemp[0][i][j+1]-k);
						 }
									
						 diff[k]+=diff_sq[k][i][j+1]; //neighbors difference
					   }		
				 }
			}


//////////// combine by Bayes rule log p(X|Y) = log(p(Y|X)  + p(X)  + Gamma , using attenuation Function call //////////////////////////////////////////////////////////////////////////////
      for (k=1; k<=classes; k++)
          {
			if (texturevalue == 0 & edgevalue == 0 ) beta = 0.1;   // more texture region and pixel not on edge
			if (texturevalue == 0 & edgevalue != 0 ) beta = 0.01;	// more texture region and pixel  on edge
			if (texturevalue == 255 & edgevalue == 0 ) beta = 1.5; // less texture region and pixel not on edge
			if (texturevalue == 255 & edgevalue != 0 ) beta = 0.01; // less texture region and pixel  on edge

            /* calculating gamma term */
		    if (atlas[0][i][j] == k)   gamma[0][i][j] = 0;
            if (atlas[0][i][j] != k)   gamma[0][i][j] = 1;

			if (prior[k] < 0) (prior[k]=0); assist =  gama * gamma[0][i][j];
			/* Switch for atlas method */
			if (ATLAS==1)
                 logpost[k] = diff[k] + beta*(double)(prior[k]) + assist;
            if (ATLAS==0)
				logpost[k] = con[k] + alpha*(diff[k]/d[k]) + beta*(double)(prior[k]);
	      }

 return *logpost;
}


///////////////////////////////////////////////////////////////////////////////////
//																				 //
//    Part 3:																	 //
//			Revised MAP Estimation Function                                      //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////



void map3(double **y[], double **xt[], double **diff_y[], double **diff_Cr[], double **diff_Cb[], double **atlas[], double beta,double gama, int ATLAS, int ICM, int cols, int rows, int classes, int map_iter, double *v, double *yaccum, double *ysquaredaccum,double *Num,unsigned char **xttemp[],unsigned char **xttempCr[],unsigned char **xttempCb[],IplImage*texture,IplImage*textureCb,IplImage*textureCr,IplImage*highpass,IplImage*highpassCr,IplImage*highpassCb)////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
	gamma[0] = (unsigned char **)get_img(cols,rows,sizeof(unsigned char));
	double logpost[MAX_CLASSES+1],logpostCr[MAX_CLASSES+1], logpostCb[MAX_CLASSES+1],logposty[MAX_CLASSES+1];
	xrv= (double **)get_img(cols,rows,sizeof(double));
	diff[0]=0;
	logpost[0]=0;
	prior[0]=0;


	readseed();

////////////////////////////////////////////////////////////////////////////////

	double sqrt2pi,con[MAX_CLASSES+1],d[MAX_CLASSES+1];
	double mean[MAX_CLASSES+1], var[MAX_CLASSES+1];

	/*  constant  */
	sqrt2pi = sqrt(2.0*PI);

	/*  constants for each class due to variance  */
	for (k=1; k<=classes; k++)
		{
			if (v[k]<0.025) v[k]=0.025;
			else con[k] = log(sqrt2pi*sqrt(v[k]));

			if (con[k] < 0) con[k] = 0;
			else d[k] = 2.0*v[k];

	/*		for (i=0; i<rows; i++)
				for (j=0; j<cols; j++)
					{	
						diff_y[k][i][j] = diff_y[k][i][j]/d[k];
						diff_Cr[k][i][j] = diff_Cr[k][i][j]/d[k];
						diff_Cb[k][i][j] = diff_Cb[k][i][j]/d[k];
					 }
*/

		}
	/* initialize accumulation registers */
	for (k=1; k<=classes; k++) 
		{
			mean[k]=0;
			var[k]=0;
			yaccum[k]=0;
			ysquaredaccum[k]=0;
			Num[k]=0;
		}

///////////////////////////////////////////////////////////////////////////////////////

    /* Map loop */
   for (l=0; l<map_iter; l++)
    {
	   AveCost = 0; 

	 	/* Initialize random variable array */
	   for (i=0; i<rows; i++)
		  for (j=0; j<cols; j++)
		     {	
				xrv[i][j] = random2();
		     }

		//**************************************************************************//
		// Begin calculation pixel by pixel
	    for (i=0; i<rows; i++)
           for (j=0; j<cols; j++)
            {

		//**************************************************************************//
		// Calculating diff temm 
			    mm=(double)y[1][i][j];

/////////////////////////////////   read in texture and edge information for each pixel ////////////////////////////
				texturevalue=cvGetReal2D(texture, i, j);
				texturevalueCr=cvGetReal2D(textureCr, i, j);
				texturevalueCb=cvGetReal2D(textureCb, i, j);

				if(texturevalue==255) beta=0.1; //    texture
				if(texturevalue==0) beta=0.01;
           
				edgevalue=cvGetReal2D(highpass, i, j);
				*logposty=callogpost(diff_y,atlas,xttemp,cols, rows,  ATLAS,  gama, classes,  beta,  d, con,logposty,edgevalue,texturevalue,highpass,texture);
				
				edgevalue=cvGetReal2D(highpassCr, i, j);
				*logpostCr=callogpost(diff_Cr,atlas,xttempCr,cols, rows,  ATLAS,  gama, classes,  beta,  d, con, logpostCr,edgevalue,texturevalueCr,highpassCr,textureCr);
							
				edgevalue=cvGetReal2D(highpassCb, i, j);
				*logpostCb=callogpost(diff_Cb,atlas,xttempCb,cols, rows,  ATLAS,  gama, classes,  beta,  d, con,logpostCb,edgevalue,texturevalueCb,highpassCb,textureCb);

				for (k=1; k<=MAX_CLASSES; k++)
				  { 
					logpost[k]=(logposty[k]+logpostCr[k]+logpostCb[k]);	
				  }
               
                /*  find min of logpost[k] */
                if (ICM == 1)
                {
                    tempmin = 1;
                    for (k=1; k<=classes; k++)
                    {
                        if ((logpost[tempmin])>(logpost[k])) tempmin=k;
                    }
                    xttemp[0][i][j]=tempmin;
					xttempCr[0][i][j]=tempmin;
					xttempCb[0][i][j]=tempmin;                  
                }
                else 
				{	
					if (ICM == 0) invannealtemp = log((float)(l+2))/3.0;
					if (ICM == 2) invannealtemp = 1.0;
					sum=0;
					for (k=1; k<=classes; k++) 
					{
						compare[k] = exp(-invannealtemp*logpost[k]*10);
						sum += compare[k];
					}

					while (sum==0)
					{
					  for (k=1; k<=classes; k++) 
						{	
						  compare[k] = exp(-invannealtemp*logpost[k]/100);
						  sum += compare[k];
						}		
					}

					current = 0;

					for (k=1; k<=classes; k++)
					{
						ratio=(compare[k])/sum;
					
						if (((xrv[i][j])>=current)&&((xrv[i][j])<=(current + ratio)))
						{
							xttemp[0][i][j] = k;
							xttempCr[0][i][j] = k;
							xttempCb[0][i][j] = k;
						}
			
                        current += ratio;
					}
				}

				# pragma omp critical 
						{
							yaccum[(xttemp[0][i][j])] += mm;					/* for mean EM calculation*/ 
							ysquaredaccum[(xttemp[0][i][j])] += (mm)*(mm);		/* for variance EM caculation */
							Num[(xttemp[0][i][j])] += 1;						/* for mean & variance EM calculation*/ 										
						}				

			AveCost += logpost[xttemp[0][i][j]];
		} 

	//**************************************************************************//
			std::cout<<"Total cost for iteration #"<<l<<" is : "<<AveCost<<"\n";
		
    for (i=0; i<rows; i++)
        for (j=0; j<cols; j++)
        {
            xt[0][i][j] = unsigned(255.0-((256.0/MAX_CLASSES)*(xttemp[0][i][j]-1.0)));
        } 

    }

}



